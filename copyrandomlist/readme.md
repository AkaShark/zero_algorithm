# 复杂链表的复制

##### 请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。

**示例1**
![示例1](img1.png)
> 输入：  
> head = [[7,null],[13,0],[11,4],[10,2],[1,0]]   
> 输出：  
> [[7,null],[13,0],[11,4],[10,2],[1,0]]

**示例2**
![示例1](img2.png)
> 输入：   
> head = [[1,1],[2,1]]   
> 输出：   
> [[1,1],[2,1]]

**示例3**
![示例1](img3.png)
> 输入：   
> head = [[3,null],[3,0],[3,null]]   
> 输出：   
> [[3,null],[3,0],[3,null]]   

**示例4**
> 输入：   
> head = []   
> 输出：[]   
> 解释：给定的链表为空（空指针），因此返回 null。   

**提示**
+ -10000 <= Node.val <= 10000   
+ Node.random 为空（null）或指向链表中的节点。   
+ 节点数目不超过 1000 。   

**思路1**
> 先使用哈希表建立旧节点和复制节点的一对一映射关系，   
> 然后遍历旧链表，将新节点一一连起来即可   

**思路2**
> 1. 复制新节点连接到原节点之后，处理成node1 -> node1(new) -> node2 -> node2(new) ->...的形式   
> 2. 处理新节点的random的连接，此时新节点的random就应当是前一个节点的random的后继节点 即 node1(new).random = node1.random.next   
> 3. 拆分新旧链表，并断开新旧链表的连接。   

**实现**
> 实现1：   
> 见 CopyRandomList1 源码   
> 时间复杂度 O(n) 空间复杂度 O(n)   
> n代表链表长度
>
> 实现2：
> 见 CopyRandomList2 源码
> 时间复杂度 O(n)三轮遍历 空间复杂度 O(1)   
> n代表链表长度